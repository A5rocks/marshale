searchNodes=[{"doc":"A collection of helper functions for Marshale.ModelMagic.defmodel/1.","ref":"Marshale.ModelMagic.html","title":"Marshale.ModelMagic","type":"module"},{"doc":"Returns AST for a Marshale.ModelUtil.convert/2 call based on a passed in type. To be more specific, this returns the AST for the anonymous function call, which in non-AST terms would look like this: &amp;Marshale.ModelUtil.convert(&amp;1, &lt;type&gt;) Examples iex&gt; Macro.to_string(Marshale.ModelMagic.convert_function(String)) &quot;&amp;(Marshale.ModelUtil.convert(&amp;1, String))&quot;","ref":"Marshale.ModelMagic.html#convert_function/1","title":"Marshale.ModelMagic.convert_function/1","type":"function"},{"doc":"Creates a model in the current module. This does the following: typedocs accordingly types accordingly creates a __from_map__/1 which converts to the types you specify this only Marshale.ModelUtil.convert/2s to types where Marshale.ModelMagic.is_marshale_module?/1 returns true. creates a struct in the current module with the given fields","ref":"Marshale.ModelMagic.html#defmodel/1","title":"Marshale.ModelMagic.defmodel/1","type":"macro"},{"doc":"Returns AST for a @typedoc statement from a line number, and the SimpleAST™️. This function gets the documentation for a variable using Marshale.ModelMagic.get_typedoc/2, then creates a @typedoc [documentation], which it then returns the AST for (or nil if the variable has no documentation associated with it). Examples iex&gt; Macro.to_string(Marshale.ModelMagic.document_line( ...&gt; 3, ...&gt; [{2, :document, &quot;Onwards and upwards&quot;}] ...&gt; )) &quot;@typedoc(\\&quot;Onwards and upwards\\&quot;)&quot;","ref":"Marshale.ModelMagic.html#document_line/2","title":"Marshale.ModelMagic.document_line/2","type":"function"},{"doc":"Returns a list which when Enum.flat_map/2-ed is the AST lines for documenting a variable. Takes in the SimpleAST™️ form of a variable and the whole SimpleAST™️ region, and outputs said AST lines for documenting the variable. Examples iex&gt; Macro.to_string(Marshale.ModelMagic.document_type( ...&gt; {3, :set, :foo, :bar}, ...&gt; [{2, :document, &quot;baz&quot;}, ...&gt; {3, :set, :foo, :bar}] ...&gt; )) &quot;[@typedoc(\\&quot;baz\\&quot;), @type(foo :: bar)]&quot;","ref":"Marshale.ModelMagic.html#document_type/2","title":"Marshale.ModelMagic.document_type/2","type":"function"},{"doc":"Gets the typedoc for a variable (or nil is there is none). Takes in the line number of the variable, and the SimpleAST™️ of the block. It returns a string which is what the variable is typedoc-ed as, or nil. Examples iex&gt; Marshale.ModelMagic.get_typedoc(3, [ ...&gt; {1, :document, &quot;Hello, world!&quot;}, ...&gt; {3, :set, :foo, :Bar} ...&gt; ]) &quot;Hello, world!&quot; iex&gt; Marshale.ModelMagic.get_typedoc(3, [{3, :set, :foo, :Bar}]) nil","ref":"Marshale.ModelMagic.html#get_typedoc/2","title":"Marshale.ModelMagic.get_typedoc/2","type":"function"},{"doc":"Takes in a ~s&#39;s or ~S&#39;s AST and returns the inner string. This may prevent interpolation from ~s (I have not checked), but is a good compromise between simplicity and feature-complete-ness. If the passed in argument is not ~s&#39;s or ~S&#39;s AST, then this function just returns said argument. Examples iex&gt; Marshale.ModelMagic.handle_sigil_s( ...&gt; {:sigil_S, [line: 2], [{:&lt;&lt;&gt;&gt;, [line: 2], [&quot;Aloha!&quot;]}, []]} ...&gt; ) &quot;Aloha!&quot; iex&gt; Marshale.ModelMagic.handle_sigil_s(&quot;Aloha!&quot;) &quot;Aloha!&quot;","ref":"Marshale.ModelMagic.html#handle_sigil_s/1","title":"Marshale.ModelMagic.handle_sigil_s/1","type":"function"},{"doc":"Detects whether a passed in module has __from_map__/1. This is the only test of whether of something is a Marshale module, allowing for basic modules to be assembled by hand, allowing for type conversions not of the map to struct type. Examples iex&gt; defmodule Snowflake do ...&gt; def __from_map__(string) when is_binary(string) do ...&gt; String.to_integer(string) ...&gt; end ...&gt; ...&gt; def __from_map__(default) do ...&gt; default ...&gt; end ...&gt; end iex&gt; Marshale.ModelMagic.is_marshale_module?(Snowflake) true","ref":"Marshale.ModelMagic.html#is_marshale_module?/1","title":"Marshale.ModelMagic.is_marshale_module?/1","type":"function"},{"doc":"Turns AST to a SimpleAST™️ representation. This helps out with processing it, as it turns the AST which has tons of encapsulation into 2 possible different flat lines. They are: {line_number, :set, variable_name, type} {line_number, :document, documentation} Just do quote do: a = :b and look at the mess that is for processing easily. That&#39;s exactly why this method exists. Examples iex&gt; Marshale.ModelMagic.manipulate_line( ...&gt; {:=, [line: 1], [ ...&gt; {:foo, [line: 1], nil}, ...&gt; {:__aliases__, [line: 1], [:bar]} ...&gt; ]} ...&gt; ) {1, :set, :foo, :&quot;Elixir.bar&quot;} iex&gt; Marshale.ModelMagic.manipulate_line( ...&gt; {:@, [line: 1], [{:typedoc, [line: 1], [&quot;Aloha!&quot;]}]} ...&gt; ) {1, :document, &quot;Aloha!&quot;}","ref":"Marshale.ModelMagic.html#manipulate_line/1","title":"Marshale.ModelMagic.manipulate_line/1","type":"function"},{"doc":"Returns AST for a Map.update/4 call based on field name and function. The input should be a tuple of field name and function. To be specific, the output and the input function are both AST. I highly recommend using Marshale.ModelMagic.convert_function/1 to generate the input function AST. Examples iex&gt; Macro.to_string(Marshale.ModelMagic.map_update_function({ ...&gt; :foo, ...&gt; Marshale.ModelMagic.convert_function(String) ...&gt; })) &quot;Map.update(:foo, nil, &amp;(Marshale.ModelUtil.convert(&amp;1, String)))&quot;","ref":"Marshale.ModelMagic.html#map_update_function/1","title":"Marshale.ModelMagic.map_update_function/1","type":"function"},{"doc":"Namespaces an atom. This both prepends :Elixir. to it, and also combines multiple names to allow things such as :&quot;Marshale.ModelMagic&quot; instead of just :ModelMagic and the like. Examples iex&gt; function_exported?(:String, :downcase, 1) false iex&gt; function_exported?(Marshale.ModelMagic.namespace_types(:String), :downcase, 1) true iex&gt; Marshale.ModelMagic.namespace_types([:Marshale, :ModelMagic]) Marshale.ModelMagic","ref":"Marshale.ModelMagic.html#namespace_types/1","title":"Marshale.ModelMagic.namespace_types/1","type":"function"},{"doc":"Constructs a pipeline from a list. In more specific, it should be able to a list of anything, but in practice, that &quot;anything&quot; is normally atoms. It returns the AST for a pipeline, too. Examples iex&gt; Macro.to_string(Marshale.ModelMagic.pipe([100, :foo, :bar])) &quot;100 |&gt; :foo |&gt; :bar&quot; iex&gt; piped = Marshale.ModelMagic.pipe([100, (quote do: div(2)), (quote do: div(5))]) {:|&gt;, [], [{:|&gt;, [], [100, {:div, [], [2]}]}, {:div, [], [5]}]} iex&gt; Macro.to_string(Macro.expand_once(piped, __ENV__)) &quot;div(div(100, 2), 5)&quot;","ref":"Marshale.ModelMagic.html#pipe/1","title":"Marshale.ModelMagic.pipe/1","type":"function"},{"doc":"Removes the last element from a list. This function is basically taken from StackOverflow, but is here because Marshale.ModelMagic.pipe/1 requires it as a helper function. Examples iex&gt; Marshale.ModelMagic.pop_tail([]) {:err, &quot;Can&#39;t pop the tail of an empty list&quot;} iex&gt; Marshale.ModelMagic.pop_tail([1, 2, 7, 3]) [1, 2, 7]","ref":"Marshale.ModelMagic.html#pop_tail/1","title":"Marshale.ModelMagic.pop_tail/1","type":"function"},{"doc":"Returns the last element of a list. The code is basically Marshale.ModelMagic.pop_tail/1, but slightly modified. It&#39;s only here due to the fact Elixir includes no such utility to do this, and because both Marshale.ModelMagic.get_typedoc/2 and Marshale.ModelMagic.pipe/1 need it. Examples iex&gt; Marshale.ModelMagic.tail([]) {:err, &quot;Can&#39;t take the tail of an empty list&quot;} iex&gt; Marshale.ModelMagic.tail([1, 2, 7, 3]) 3","ref":"Marshale.ModelMagic.html#tail/1","title":"Marshale.ModelMagic.tail/1","type":"function"},{"doc":"","ref":"Marshale.ModelUtil.html","title":"Marshale.ModelUtil","type":"module"},{"doc":"","ref":"Marshale.ModelUtil.html#convert/2","title":"Marshale.ModelUtil.convert/2","type":"function"},{"doc":"Marshale Make making models easier on yourself.","ref":"readme.html","title":"Marshale","type":"extras"},{"doc":"Just do this to your mix.exs: def deps do [ {:marshale, git: &quot;git://github.com/A5rocks/marshale.git&quot;}, ... ] end And now, you can define models in a subset of Elixir, like so: defmodule ExampleInteger do @doc false def __from_map__(object) def __from_map__(string) when is_binary(string) do String.to_integer(string) end def __from_map__(item) do item end end defmodule Foo do use Marshale.ModelMagic defmodel do bar = ExampleInteger @typedoc ~S&quot;`baz` is a list of `ExampleInteger`s&quot; baz = [ExampleInteger] id = Integer end end This allows typedocs to propagate properly and allows for the following: iex&gt; Foo.__from_map__(%{bar: &quot;5&quot;, baz: [&quot;1&quot;, &quot;2&quot;, &quot;7&quot;, &quot;3&quot;], id: &quot;42&quot;}) %Foo{bar: 5, baz: [1, 2, 7, 3], id: &quot;42&quot;}","ref":"readme.html#installation","title":"Marshale - Installation","type":"extras"}]